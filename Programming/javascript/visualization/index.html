<html>
<head>
    <!-- Link to latest version of D3.js and other dependencies needed for the plotting library--->
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>

    <link rel="stylesheet" href="style.css">
</head>
<body>
<div id="title">
    <h1>Visualization</h1>
</div>
<div>
    <textarea placeholder="input a post..." rows="6" name="content" class="postContent" id="input"></textarea>
    <button class="Submit">Submit</button>
</div>
<div id="reactions">
    <h2>Reaction Distribution</h2>
</div>
<div id="piechart">
    <h2>Emotion Analysis</h2>
</div>
<div id="emotionWordTable">
    <h2>Emotion Words</h2>
    <table id="emotionWords">
        <tr>
            <td>Lorem Ipsum</td>
            <td>Dolor Sit Amet</td>
        </tr>
        <tr>
            <td>This is another row</td>
            <td>Let's see what we get.</td>
        </tr>
    </table>
</div>

<script>

    d3.select(".Submit").on("click", function () {
        //Retrieve the text from the textfield.
        var text = document.getElementById("input").value;


        var data = {"post": text}
        //Prepare the connection
        var xhr = new XMLHttpRequest();
        xhr.open("POST", "http://localhost:5000/predict/single");
        xhr.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
        xhr.responseType = 'json';
        xhr.onload = function () { //Handles the response by the server
            var status = xhr.status;
            if (status == 200) {
                console.log(xhr.response)
                var response = xhr.response;
                console.log("Received response: " + response);

                //Update the emotions
                var emotions = [];

                j = 0;
                for (var i in response.emotions) {
                    emotions[j] = {label: i, value: response.emotions[i]};
                    j++;

                }
                //Update the Donut Chart
                updateDonut(emotions);


                //Extract the reactions
                var values = [];

                j = 0;
                for (var i in response.reactions) {
                    values[j] = {label: i, frequ: response.reactions[i]};
                    j++;

                }

                //Update the bars
                updateBars(values);

                //Update the emotion word table
                createEmotionWordTable(response);
            } else {

                alert('Something went wrong: ' + xhr.response);
            }
        };


        xhr.send(JSON.stringify(data));
    })


    // set the dimensions of the canvas
    var margin = {top: 20, right: 20, bottom: 70, left: 40},
        width = 300 - margin.left - margin.right,
        height = 300 - margin.top - margin.bottom;


    // set the ranges
    var x = d3.scale.ordinal().rangeRoundBands([0, width], .05);

    var y = d3.scale.linear().range([height, 0]);


    // define the axis
    var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom")


    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left")
        .ticks(10);


    // add the SVG element
    var svgReactions = d3.select("#reactions").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");


    d3.json("data.json", function (error, data) {

        //Convert the data to an easier to use format
        var values = [];

        j = 0;
        for (var i in data.reactions) {
            values[j] = {label: i, frequ: data.reactions[i]};
            j++;

        }

        // scale the range of the data
        x.domain(Object.keys(data.reactions));
        y.domain([0, 1]);
        // add axis
        svgReactions.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis)
            .selectAll("text")
            .style("text-anchor", "end")
            .attr("dx", "-.8em")
            .attr("dy", "-.55em")
            .attr("transform", "rotate(-90)");

        svgReactions.append("g")
            .attr("class", "y axis")
            .call(yAxis)
            .append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 5)
            .attr("dy", ".71em")
            .style("text-anchor", "end")
            .text("Frequency");


        // Add bar chart
        svgReactions.selectAll("bar")
            .data(values)
            .enter().append("rect")
            .attr("class", "reactionsBar")
            .attr("x", function (d) {
                return x(d.label);
            })
            .attr("width", x.rangeBand())
            .attr("y", function (d) {
                return y(d.frequ);
            })
            .attr("height", function (d) {
                return height - y(d.frequ);
            });

    });

    var svg = d3.select("#piechart")
        .append("svg").attr("class", "donutChart")
        .append("g")


    svg.append("g")
        .attr("class", "slices");
    svg.append("g")
        .attr("class", "labels");
    svg.append("g")
        .attr("class", "lines");

    var width = 480, //These are the canvas width and height, donut applies best fit (fill).
        height = 225,
        radius = Math.min(width, height) / 2;

    var pie = d3.layout.pie()
        .sort(null)
        .value(function (d) {
            return d.value;
        });

    var arc = d3.svg.arc()
        .outerRadius(radius * 0.8)
        .innerRadius(radius * 0.4);

    var outerArc = d3.svg.arc()
        .innerRadius(radius * 0.9)
        .outerRadius(radius * 0.9);

    svg.attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    var key = function (d) {
        return d.data.label;
    };
    console.log(key);

    //Define the emotions and their colours.
    var color = d3.scale.ordinal()
        .domain(["ANGER", "ANTICIPATION", "DISGUST", "FEAR", "JOY", "SADNESS", "SURPRISE", "TRUST"])
        .range(["#d62222", "#ffff00", "#b266ff", "#00e9ff", "#1ae024", "#0a5866", "#ffdf3f", "#8c3a6f"]);

    //Sets the emotions to random data.
    function randomData() {
        var labels = color.domain();
        return labels.map(function (label) {
            return {label: label, value: Math.random()}
        });
    }

    //Initializes an empty donut.
    function initDonut() {
        var labels = color.domain();
        return labels.map(function (label) {
            return {label: label, value: 0}
        });
    }

    //Initialization (Empty Donut).
    updateDonut(initDonut());

    //updateBars(); //TODO: Remove this test line


    function updateBars(values) {


        //TODO: Remove test code
        var likes = Math.random();
        var angry = Math.random() * (1 - likes);
        var sad = 1 - likes - angry;

        values = [{label : "Like", frequ : likes}, {label : "Angry", frequ : angry}, {label : "Sad", frequ : sad}]
        console.log(values);
        var bar = svgReactions.selectAll(".reactionsBar"); //TODO: Implement the update method.
        bar.data(values);
        console.log("Bar: " + bar);
        console.log(bar);
        svgReactions.selectAll(".reactionsBar").transition()
            .attr("x", function (d) {
                console.log("D has value:" + d.label);
                return x(d.label);
            })
            .attr("y", function (d) {
                return y(d.frequ);
            })
            .attr("height", function (d) {
                console.log(d.frequ);
                return height - y(d.frequ);
            })
            .attr("width", x.rangeBand());
    }

    function createEmotionWordTable(data){
        //Select the table and clear the old data
        var tab = d3.select("#emotionWords");
        tab.selectAll("*").remove();

        //TODO: Build the new table


    }

    //Updates the donut
    function updateDonut(data) {

        /* ------- PIE SLICES -------*/
        var slice = svg.select(".slices").selectAll("path.slice")
            .data(pie(data), key);

        slice.enter()
            .insert("path")
            .style("fill", function (d) {
                return color(d.data.label);
            })
            .attr("class", "slice");

        slice
            .transition().duration(1000)
            .attrTween("d", function (d) {
                this._current = this._current || d;
                var interpolate = d3.interpolate(this._current, d);
                this._current = interpolate(0);
                return function (t) {
                    return arc(interpolate(t));
                };
            })

        slice.exit()
            .remove();

        /* ------- TEXT LABELS -------*/

        var text = svg.select(".labels").selectAll("text")
            .data(pie(data), key);

        text.enter()
            .append("text")
            .attr("dy", ".35em")
            .text(function (d) {
                return d.data.label;
            });

        function midAngle(d) {
            return d.startAngle + (d.endAngle - d.startAngle) / 2;
        }

        text.transition().duration(1000)
            .attrTween("transform", function (d) {
                this._current = this._current || d;
                var interpolate = d3.interpolate(this._current, d);
                this._current = interpolate(0);
                return function (t) {
                    var d2 = interpolate(t);
                    var pos = outerArc.centroid(d2);
                    pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);
                    return "translate(" + pos + ")";
                };
            })
            .styleTween("text-anchor", function (d) {
                this._current = this._current || d;
                var interpolate = d3.interpolate(this._current, d);
                this._current = interpolate(0);
                return function (t) {
                    var d2 = interpolate(t);
                    return midAngle(d2) < Math.PI ? "start" : "end";
                };
            });

        text.exit()
            .remove();

        /* ------- SLICE TO TEXT POLYLINES -------*/

        var polyline = svg.select(".lines").selectAll("polyline")
            .data(pie(data), key);

        polyline.enter()
            .append("polyline");

        polyline.transition().duration(1000)
            .attrTween("points", function (d) {
                this._current = this._current || d;
                var interpolate = d3.interpolate(this._current, d);
                this._current = interpolate(0);
                return function (t) {
                    var d2 = interpolate(t);
                    var pos = outerArc.centroid(d2);
                    pos[0] = radius * 0.95 * (midAngle(d2) < Math.PI ? 1 : -1);
                    return [arc.centroid(d2), outerArc.centroid(d2), pos];
                };
            });

        polyline.exit()
            .remove();
    };


</script>


</body>
</html>